import {
  require_client
} from "./chunk-GPG6DDUL.js";
import {
  require_react_dom
} from "./chunk-KDCVS43I.js";
import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/react-simple-toasts/dist/index.es.js
var import_react = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());
var ReactDOMClient = __toESM(require_client());
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var createElement = function(id) {
  var element = document.createElement("div");
  element.setAttribute("id", id);
  return element;
};
var addRootElement = function(rootElem) {
  document.body.appendChild(rootElem);
  return rootElem;
};
var fullClone = __assign(__assign({}, ReactDOM), ReactDOMClient);
var version = fullClone.version;
var reactRender = fullClone.render;
fullClone.unmountComponentAtNode;
var createRoot;
try {
  mainVersion = Number((version || "").split(".")[0]);
  if (mainVersion >= 18 && fullClone.createRoot) {
    createRoot = fullClone.createRoot;
  }
} catch (e) {
}
var mainVersion;
function toggleWarning(skip) {
  var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && typeof __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === "object") {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
  }
}
var MARK = "__rc_react_root__";
function modernRender(node, container) {
  toggleWarning(true);
  var root = container[MARK] || createRoot(container);
  toggleWarning(false);
  root.render(node);
  container[MARK] = root;
}
function legacyRender(node, container) {
  reactRender === null || reactRender === void 0 ? void 0 : reactRender(node, container);
}
function render(node, container) {
  if (createRoot != null) {
    modernRender(node, container);
    return;
  }
  legacyRender(node, container);
}
var createId = function() {
  return Date.now() + Math.floor(Math.random() * 1e16);
};
var isBrowser = function() {
  return typeof window !== "undefined";
};
var reverse = function(arr) {
  var result = [];
  for (var i = arr.length - 1; i >= 0; i--) {
    result.push(arr[i]);
  }
  return result;
};
var rgbToRgba = function(rgb, alpha) {
  var _a = rgb.replace(/[rgb(]|[)]/g, "").split(",").map(function(v) {
    return v.trim();
  }), r = _a[0], g = _a[1], b = _a[2];
  return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(alpha, ")");
};
var classes = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.filter(Boolean).join(" ");
};
var SET_TIMEOUT_MAX = 2147483647;
var ToastPosition = {
  BOTTOM_LEFT: "bottom-left",
  BOTTOM_CENTER: "bottom-center",
  BOTTOM_RIGHT: "bottom-right",
  TOP_LEFT: "top-left",
  TOP_CENTER: "top-center",
  TOP_RIGHT: "top-right",
  CENTER: "center"
};
var Themes = {
  DARK: "dark",
  DARK_EDGE: "dark-edge",
  LIGHT: "light",
  LIGHT_EDGE: "light-edge",
  PINK_DAWN: "pink-dawn",
  CHROMA: "chroma",
  BLUE_DUSK: "blue-dusk",
  OCEAN_WAVE: "ocean-wave",
  SUNSET: "sunset",
  MOONLIGHT: "moonlight",
  FROSTED_GLASS: "frosted-glass",
  SUCCESS: "success",
  INFO: "info",
  WARNING: "warning",
  FAILURE: "failure",
  PLAIN: "plain"
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react.default.useLayoutEffect : import_react.default.useEffect;
function Loading(_a) {
  var color = _a.color, children = _a.children;
  var translucentColor = color && rgbToRgba(color, 0.3);
  return import_react.default.createElement("span", {
    className: "toast__spinner-wrap"
  }, import_react.default.createElement("span", {
    className: "toast__spinner",
    style: {
      border: "2px solid ".concat(translucentColor),
      borderTopColor: color
    }
  }, children));
}
var TransitionClassNames = {
  enter: "toast__message--enter-active",
  exit: "toast__message--exit-active"
};
function ToastMessage(_a) {
  var id = _a.id, message = _a.message, className = _a.className, clickableProp = _a.clickable, clickClosable = _a.clickClosable, position = _a.position, isExit = _a.isExit, render2 = _a.render, theme = _a.theme, offsetX = _a.offsetX, offsetY = _a.offsetY, deltaOffsetX = _a.deltaOffsetX, deltaOffsetY = _a.deltaOffsetY, zIndex = _a.zIndex, loading = _a.loading, loadingText = _a.loadingText, onClick = _a.onClick, onClose = _a.onClose, onCloseStart = _a.onCloseStart, _onEnter = _a._onEnter;
  var clickable = clickableProp || clickClosable;
  var messageDOM = (0, import_react.useRef)(null);
  var hasTopPosition = position === null || position === void 0 ? void 0 : position.includes("top");
  var hasBottomPosition = position === null || position === void 0 ? void 0 : position.includes("bottom");
  var hasRightPosition = position === null || position === void 0 ? void 0 : position.includes("right");
  var hasLeftPosition = position === null || position === void 0 ? void 0 : position.includes("left");
  var hasCenterPosition = position === null || position === void 0 ? void 0 : position.includes("-center");
  var isCenterPosition = position === ToastPosition.CENTER;
  var _b = (0, import_react.useState)(false), isEnter = _b[0], setIsEnter = _b[1];
  var _c = (0, import_react.useState)({
    transform: "translate(".concat(deltaOffsetX, ", ").concat(isCenterPosition ? "calc(50% - 20px)" : "".concat(parseInt(deltaOffsetY || "0") + 20 * (hasTopPosition ? -1 : 1), "px"), ")")
  }), messageStyle = _c[0], setMessageStyle = _c[1];
  var _d = (0, import_react.useState)(!!loading), localLoading = _d[0], setLocalLoading = _d[1];
  var _e = (0, import_react.useState)(), loadingColor = _e[0], setLoadingColor = _e[1];
  var top = isCenterPosition ? "50%" : hasTopPosition ? offsetY : void 0;
  var bottom = hasBottomPosition ? offsetY : void 0;
  var right = hasRightPosition ? offsetX : void 0;
  var left = hasCenterPosition || isCenterPosition ? "50%" : hasLeftPosition ? offsetX : void 0;
  useIsomorphicLayoutEffect(function() {
    var transform = "translate(".concat(deltaOffsetX, ", ").concat(deltaOffsetY, ")");
    setMessageStyle({
      top,
      right,
      bottom,
      left,
      zIndex,
      transform,
      WebkitTransform: transform
    });
  }, [deltaOffsetX, deltaOffsetY, zIndex, top, right, bottom, left]);
  useIsomorphicLayoutEffect(function() {
    var _a2;
    if (((_a2 = messageDOM.current) === null || _a2 === void 0 ? void 0 : _a2.clientHeight) == null || isEnter) return;
    var width = messageDOM.current.clientWidth;
    var height = messageDOM.current.clientHeight;
    if (messageDOM.current) {
      _onEnter === null || _onEnter === void 0 ? void 0 : _onEnter({
        target: messageDOM.current,
        width,
        height
      });
    }
    setIsEnter(true);
  }, [isEnter, _onEnter]);
  useIsomorphicLayoutEffect(function() {
    if (!messageDOM.current) return;
    var messageText = messageDOM.current.querySelector("span");
    var textColor = messageText && window.getComputedStyle(messageText).color;
    if (!textColor) return;
    setLoadingColor(textColor);
  }, []);
  useIsomorphicLayoutEffect(function() {
    if (loading instanceof Promise) {
      setLocalLoading(true);
      loading.then(function() {
        setLocalLoading(false);
      });
      return;
    }
    setLocalLoading(!!loading);
  }, [loading]);
  useIsomorphicLayoutEffect(function() {
    if (isExit) {
      onCloseStart();
    }
  }, [isExit]);
  var messageClassNames = classes("toast__message", "toast__message--".concat(position || "bottom-center"), "toast__".concat(theme, "-wrapper"), isEnter ? TransitionClassNames.enter : "", isExit ? TransitionClassNames.exit : "", localLoading ? "toast__message--loading" : "");
  var contentClassNames = classes("toast__content", clickable ? "toast__content--clickable" : "", !render2 && theme ? "toast__".concat(theme) : "", !render2 && theme ? "toast__theme-content" : "", theme || "", className);
  var clickableProps = {
    onClick,
    tabIndex: 0,
    role: "button"
  };
  return import_react.default.createElement("div", {
    ref: messageDOM,
    id: id.toString(),
    className: messageClassNames,
    style: messageStyle,
    onTransitionEnd: function() {
      if (messageClassNames.includes(TransitionClassNames.exit)) {
        onClose();
      }
    }
  }, import_react.default.createElement("div", _extends({
    className: contentClassNames
  }, clickable && clickableProps), localLoading && import_react.default.createElement(Loading, {
    color: loadingColor
  }, loadingText), render2 ? render2(message) : message));
}
var isToastUpdateOptions = function(updateOptions) {
  if (updateOptions && typeof updateOptions === "object") {
    return "message" in updateOptions || "duration" in updateOptions || "loading" in updateOptions;
  }
  return false;
};
function ToastContainer(props) {
  var toastComponentList2 = props.toastComponentList, onToastEnter = props.onToastEnter;
  var handleToastEnter = function(t, e) {
    toastComponentList2.forEach(function(toast2) {
      if (toast2.id !== t.id) return;
      toast2.startCloseTimer();
      toast2.height = e.height;
    });
    onToastEnter();
  };
  return import_react.default.createElement(import_react.default.Fragment, null, toastComponentList2.map(function(t) {
    var toastComponents = t.position.includes("top") ? reverse(toastComponentList2) : toastComponentList2;
    var currentIndex = toastComponents.findIndex(function(toast2) {
      return toast2.id === t.id;
    });
    var bottomToasts = toastComponents.slice(currentIndex + 1).filter(function(toast2) {
      return toast2.position === t.position && !toast2.isExit;
    });
    var bottomToastsHeight = bottomToasts.reduce(function(acc, toast2) {
      var _a;
      return acc + ((_a = toast2.height) !== null && _a !== void 0 ? _a : 0) + t.gap;
    }, 0);
    var deltaOffsetX = t.position.includes("left") || t.position.includes("right") ? "0%" : "-50%";
    var offsetYAlpha = t.position.includes("top") ? 1 : -1;
    var baseOffsetY = bottomToastsHeight * offsetYAlpha;
    var deltaOffsetY = t.position === "center" ? "calc(-50% - ".concat(baseOffsetY * -1, "px)") : "".concat(baseOffsetY, "px");
    return import_react.default.createElement(import_react.Fragment, {
      key: t.id
    }, (0, import_react.cloneElement)(t.component, {
      isExit: t.isExit,
      deltaOffsetX,
      deltaOffsetY,
      _onEnter: function(event) {
        return handleToastEnter(t, event);
      }
    }));
  }));
}
var toastComponentList = [];
var init = function() {
  var toastContainer = isBrowser() && document.getElementById("#toast__container");
  if (isBrowser() && !toastContainer) {
    addRootElement(createElement("#toast__container"));
  }
  if (!toastComponentList || !Array.isArray(toastComponentList)) {
    toastComponentList = [];
  }
};
var noop = function() {
};
var defaultOptions = {
  duration: 3e3,
  className: "",
  position: "bottom-center",
  offsetX: 30,
  offsetY: 30,
  gap: 10,
  clickClosable: false,
  render: null,
  maxVisibleToasts: null,
  isReversedOrder: false,
  theme: null,
  loadingText: "loading",
  zIndex: 1e3,
  clickable: false,
  onClick: noop,
  onClose: noop,
  onCloseStart: noop,
  loading: false
};
var isValidPosition = function(position) {
  var positionList = Object.values(ToastPosition);
  if (!positionList.includes(position)) {
    throw new Error("Invalid position value. Expected one of ".concat(positionList.join(", "), " but got ").concat(position));
  }
  return true;
};
var validateOptions = function(options) {
  options.position && isValidPosition(options.position);
};
var toastConfig = function(options) {
  if (!isBrowser()) return;
  validateOptions(options);
  Object.assign(defaultOptions, options);
};
var renderDOM = function() {
  if (!isBrowser()) return;
  var toastContainer = document.getElementById("#toast__container");
  if (!toastContainer) return;
  render(import_react.default.createElement(ToastContainer, {
    toastComponentList,
    onToastEnter: renderDOM
  }), toastContainer);
};
var clearToasts = function() {
  toastComponentList.forEach(function(toast2) {
    return toast2.isExit = true;
  });
  renderDOM();
};
function closeToast(id) {
  var index = toastComponentList.findIndex(function(t) {
    return t.id === id;
  });
  if (toastComponentList[index]) {
    toastComponentList[index].isExit = true;
  }
  renderDOM();
}
function renderToast(message, _options) {
  var dummyReturn = {
    close: function() {
      return null;
    },
    updateDuration: function() {
      return null;
    },
    update: function() {
      return null;
    }
  };
  if (!isBrowser()) return dummyReturn;
  var closeTimer;
  var id = createId();
  var options = __assign(__assign({}, defaultOptions), _options);
  var _a = options || {}, loading = _a.loading, loadingText = _a.loadingText, onClose = _a.onClose, onCloseStart = _a.onCloseStart, clickClosable = _a.clickClosable, position = _a.position, onClick = _a.onClick, gap = _a.gap, theme = _a.theme, duration = _a.duration, isReversedOrder = _a.isReversedOrder, maxVisibleToasts = _a.maxVisibleToasts;
  var durationTime = duration === void 0 ? defaultOptions.duration : duration;
  if (!isValidPosition(position)) ;
  init();
  var handleClick = function(e) {
    if (clickClosable) {
      if (closeTimer) {
        clearTimeout(closeTimer);
      }
      closeToast(id);
    }
    onClick === null || onClick === void 0 ? void 0 : onClick(e);
  };
  var handleClose = function() {
    toastComponentList = toastComponentList.filter(function(t) {
      return t.id !== id;
    });
    renderDOM();
    onClose === null || onClose === void 0 ? void 0 : onClose();
  };
  var startCloseTimer = function(duration2) {
    if (duration2 === void 0) {
      duration2 = options.duration;
    }
    if (duration2 === null || duration2 === 0 || duration2 > SET_TIMEOUT_MAX) return;
    if (closeTimer) {
      clearTimeout(closeTimer);
    }
    closeTimer = window.setTimeout(function() {
      closeToast(id);
    }, duration2);
  };
  var newToastComponent = {
    id,
    message,
    position,
    startCloseTimer,
    gap,
    component: import_react.default.createElement(ToastMessage, _extends({}, options, {
      id,
      message,
      onClick: handleClick,
      onClose: handleClose,
      onCloseStart
    }))
  };
  if (isReversedOrder) toastComponentList.unshift(newToastComponent);
  else toastComponentList.push(newToastComponent);
  if (maxVisibleToasts) {
    var toastsToRemove = toastComponentList.length - maxVisibleToasts;
    for (var i = 0; i < toastsToRemove; i++) {
      closeToast(toastComponentList[i].id);
    }
  }
  renderDOM();
  return {
    close: function() {
      return closeToast(id);
    },
    updateDuration: function(newDuration) {
      if (newDuration === void 0) {
        newDuration = durationTime;
      }
      startCloseTimer(newDuration);
    },
    update: function(messageOrOptions, updateDuration) {
      var _a2, _b;
      var toast2 = toastComponentList.find(function(t) {
        return t.id === id && !t.isExit;
      });
      if (toast2) {
        var newDuration = isToastUpdateOptions(messageOrOptions) ? messageOrOptions.duration : updateDuration;
        var finalMessage = (_a2 = isToastUpdateOptions(messageOrOptions) ? messageOrOptions.message : messageOrOptions) !== null && _a2 !== void 0 ? _a2 : message;
        var finalLoading = isToastUpdateOptions(messageOrOptions) ? (_b = messageOrOptions.loading) !== null && _b !== void 0 ? _b : loading : false;
        var finalTheme = isToastUpdateOptions(messageOrOptions) ? messageOrOptions.theme || theme : theme;
        toast2.message = finalMessage;
        toast2.component = import_react.default.createElement(ToastMessage, _extends({}, options, {
          id,
          message: finalMessage,
          theme: finalTheme,
          loading: finalLoading,
          loadingText,
          onClick: handleClick,
          onClose: handleClose,
          onCloseStart
        }));
        renderDOM();
        if (newDuration !== void 0) {
          startCloseTimer(newDuration);
        }
      }
    }
  };
}
function toast(message, durationOrOptions) {
  var options = typeof durationOrOptions === "number" || durationOrOptions === null ? {
    duration: durationOrOptions
  } : durationOrOptions;
  return renderToast(message, options);
}
var createToast = function(options) {
  return function(message, durationOrOptions) {
    if (typeof durationOrOptions === "number") {
      return renderToast(message, {
        duration: durationOrOptions || options.duration
      });
    }
    if (durationOrOptions === void 0 || typeof durationOrOptions === "object") {
      var mergedOptions = __assign(__assign({}, options), durationOrOptions);
      return renderToast(message, mergedOptions);
    }
    throw new Error("Invalid durationOrOptions type");
  };
};
export {
  Themes,
  clearToasts,
  createToast,
  toast as default,
  toast,
  toastConfig
};
//# sourceMappingURL=react-simple-toasts.js.map
